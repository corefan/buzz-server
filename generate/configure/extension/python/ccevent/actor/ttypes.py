#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import ccevent.ttypes
import ccentity.actor.ttypes
import ccentity.vip.ttypes
import ccentity.resource.ttypes
import ccentity.npc.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class EventActorLogin:
  """
  Attributes:
   - id_
   - map_
   - x_
   - y_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id_', None, None, ), # 1
    (2, TType.I16, 'map_', None, None, ), # 2
    (3, TType.I32, 'x_', None, None, ), # 3
    (4, TType.I32, 'y_', None, None, ), # 4
  )

  def __init__(self, id_=None, map_=None, x_=None, y_=None,):
    self.id_ = id_
    self.map_ = map_
    self.x_ = x_
    self.y_ = y_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.map_ = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.x_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.y_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorLogin')
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 1)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    if self.map_ is not None:
      oprot.writeFieldBegin('map_', TType.I16, 2)
      oprot.writeI16(self.map_)
      oprot.writeFieldEnd()
    if self.x_ is not None:
      oprot.writeFieldBegin('x_', TType.I32, 3)
      oprot.writeI32(self.x_)
      oprot.writeFieldEnd()
    if self.y_ is not None:
      oprot.writeFieldBegin('y_', TType.I32, 4)
      oprot.writeI32(self.y_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    if self.map_ is None:
      raise TProtocol.TProtocolException(message='Required field map_ is unset!')
    if self.x_ is None:
      raise TProtocol.TProtocolException(message='Required field x_ is unset!')
    if self.y_ is None:
      raise TProtocol.TProtocolException(message='Required field y_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorLogout:
  """
  Attributes:
   - id_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id_', None, None, ), # 1
  )

  def __init__(self, id_=None,):
    self.id_ = id_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorLogout')
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 1)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorSave:
  """
  Attributes:
   - id_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id_', None, None, ), # 1
  )

  def __init__(self, id_=None,):
    self.id_ = id_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorSave')
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 1)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorExtensionLoadFinish:
  """
  Attributes:
   - id_
   - extension_type_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id_', None, None, ), # 1
    (2, TType.I32, 'extension_type_', None, None, ), # 2
  )

  def __init__(self, id_=None, extension_type_=None,):
    self.id_ = id_
    self.extension_type_ = extension_type_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.extension_type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorExtensionLoadFinish')
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 1)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    if self.extension_type_ is not None:
      oprot.writeFieldBegin('extension_type_', TType.I32, 2)
      oprot.writeI32(self.extension_type_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    if self.extension_type_ is None:
      raise TProtocol.TProtocolException(message='Required field extension_type_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorLoadFinish:
  """
  Attributes:
   - id_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id_', None, None, ), # 1
  )

  def __init__(self, id_=None,):
    self.id_ = id_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorLoadFinish')
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 1)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorDailyClean:
  """
  Attributes:
   - actor_
   - days_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
    (2, TType.I32, 'days_', None, None, ), # 2
  )

  def __init__(self, actor_=None, days_=None,):
    self.actor_ = actor_
    self.days_ = days_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.days_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorDailyClean')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    if self.days_ is not None:
      oprot.writeFieldBegin('days_', TType.I32, 2)
      oprot.writeI32(self.days_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorWeeklyClean:
  """
  Attributes:
   - actor_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
  )

  def __init__(self, actor_=None,):
    self.actor_ = actor_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorWeeklyClean')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorTalkNpc:
  """
  Attributes:
   - actor_id_
   - npc_id_
   - task_id_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_id_', None, None, ), # 1
    (2, TType.I32, 'npc_id_', None, None, ), # 2
    (3, TType.I32, 'task_id_', None, 0, ), # 3
  )

  def __init__(self, actor_id_=None, npc_id_=None, task_id_=thrift_spec[3][4],):
    self.actor_id_ = actor_id_
    self.npc_id_ = npc_id_
    self.task_id_ = task_id_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.npc_id_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.task_id_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorTalkNpc')
    if self.actor_id_ is not None:
      oprot.writeFieldBegin('actor_id_', TType.I64, 1)
      oprot.writeI64(self.actor_id_)
      oprot.writeFieldEnd()
    if self.npc_id_ is not None:
      oprot.writeFieldBegin('npc_id_', TType.I32, 2)
      oprot.writeI32(self.npc_id_)
      oprot.writeFieldEnd()
    if self.task_id_ is not None:
      oprot.writeFieldBegin('task_id_', TType.I32, 3)
      oprot.writeI32(self.task_id_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_id_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_id_ is unset!')
    if self.npc_id_ is None:
      raise TProtocol.TProtocolException(message='Required field npc_id_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorLevelUp:
  """
  Attributes:
   - actor_id_
   - old_level_
   - new_level_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_id_', None, None, ), # 1
    (2, TType.I32, 'old_level_', None, None, ), # 2
    (3, TType.I32, 'new_level_', None, None, ), # 3
  )

  def __init__(self, actor_id_=None, old_level_=None, new_level_=None,):
    self.actor_id_ = actor_id_
    self.old_level_ = old_level_
    self.new_level_ = new_level_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.old_level_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.new_level_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorLevelUp')
    if self.actor_id_ is not None:
      oprot.writeFieldBegin('actor_id_', TType.I64, 1)
      oprot.writeI64(self.actor_id_)
      oprot.writeFieldEnd()
    if self.old_level_ is not None:
      oprot.writeFieldBegin('old_level_', TType.I32, 2)
      oprot.writeI32(self.old_level_)
      oprot.writeFieldEnd()
    if self.new_level_ is not None:
      oprot.writeFieldBegin('new_level_', TType.I32, 3)
      oprot.writeI32(self.new_level_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_id_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_id_ is unset!')
    if self.old_level_ is None:
      raise TProtocol.TProtocolException(message='Required field old_level_ is unset!')
    if self.new_level_ is None:
      raise TProtocol.TProtocolException(message='Required field new_level_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorFunctionalityEnable:
  """
  Attributes:
   - actor_id_
   - functionality_id_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_id_', None, None, ), # 1
    (2, TType.I32, 'functionality_id_', None, None, ), # 2
  )

  def __init__(self, actor_id_=None, functionality_id_=None,):
    self.actor_id_ = actor_id_
    self.functionality_id_ = functionality_id_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.functionality_id_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorFunctionalityEnable')
    if self.actor_id_ is not None:
      oprot.writeFieldBegin('actor_id_', TType.I64, 1)
      oprot.writeI64(self.actor_id_)
      oprot.writeFieldEnd()
    if self.functionality_id_ is not None:
      oprot.writeFieldBegin('functionality_id_', TType.I32, 2)
      oprot.writeI32(self.functionality_id_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_id_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_id_ is unset!')
    if self.functionality_id_ is None:
      raise TProtocol.TProtocolException(message='Required field functionality_id_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorKillNpc:
  """
  Attributes:
   - actor_
   - npc_
   - npc_template_
   - type_
   - npc_level_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
    (2, TType.I64, 'npc_', None, None, ), # 2
    (3, TType.I32, 'npc_template_', None, None, ), # 3
    (4, TType.I32, 'type_', None, None, ), # 4
    (5, TType.I32, 'npc_level_', None, None, ), # 5
  )

  def __init__(self, actor_=None, npc_=None, npc_template_=None, type_=None, npc_level_=None,):
    self.actor_ = actor_
    self.npc_ = npc_
    self.npc_template_ = npc_template_
    self.type_ = type_
    self.npc_level_ = npc_level_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.npc_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.npc_template_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.npc_level_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorKillNpc')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    if self.npc_ is not None:
      oprot.writeFieldBegin('npc_', TType.I64, 2)
      oprot.writeI64(self.npc_)
      oprot.writeFieldEnd()
    if self.npc_template_ is not None:
      oprot.writeFieldBegin('npc_template_', TType.I32, 3)
      oprot.writeI32(self.npc_template_)
      oprot.writeFieldEnd()
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 4)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.npc_level_ is not None:
      oprot.writeFieldBegin('npc_level_', TType.I32, 5)
      oprot.writeI32(self.npc_level_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_ is unset!')
    if self.npc_ is None:
      raise TProtocol.TProtocolException(message='Required field npc_ is unset!')
    if self.npc_template_ is None:
      raise TProtocol.TProtocolException(message='Required field npc_template_ is unset!')
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.npc_level_ is None:
      raise TProtocol.TProtocolException(message='Required field npc_level_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorCompare:
  """
  Attributes:
   - actor_
   - compare_actor_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
    (2, TType.I64, 'compare_actor_', None, None, ), # 2
  )

  def __init__(self, actor_=None, compare_actor_=None,):
    self.actor_ = actor_
    self.compare_actor_ = compare_actor_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.compare_actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorCompare')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    if self.compare_actor_ is not None:
      oprot.writeFieldBegin('compare_actor_', TType.I64, 2)
      oprot.writeI64(self.compare_actor_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_ is unset!')
    if self.compare_actor_ is None:
      raise TProtocol.TProtocolException(message='Required field compare_actor_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorVipChange:
  """
  Attributes:
   - actor_
   - old_type_
   - new_type_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
    (2, TType.I32, 'old_type_', None, None, ), # 2
    (3, TType.I32, 'new_type_', None, None, ), # 3
  )

  def __init__(self, actor_=None, old_type_=None, new_type_=None,):
    self.actor_ = actor_
    self.old_type_ = old_type_
    self.new_type_ = new_type_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.old_type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.new_type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorVipChange')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    if self.old_type_ is not None:
      oprot.writeFieldBegin('old_type_', TType.I32, 2)
      oprot.writeI32(self.old_type_)
      oprot.writeFieldEnd()
    if self.new_type_ is not None:
      oprot.writeFieldBegin('new_type_', TType.I32, 3)
      oprot.writeI32(self.new_type_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_ is unset!')
    if self.old_type_ is None:
      raise TProtocol.TProtocolException(message='Required field old_type_ is unset!')
    if self.new_type_ is None:
      raise TProtocol.TProtocolException(message='Required field new_type_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorResourceChange:
  """
  Attributes:
   - actor_
   - type_
   - old_num_
   - new_num_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
    (2, TType.I32, 'type_', None, None, ), # 2
    (3, TType.I32, 'old_num_', None, None, ), # 3
    (4, TType.I32, 'new_num_', None, None, ), # 4
  )

  def __init__(self, actor_=None, type_=None, old_num_=None, new_num_=None,):
    self.actor_ = actor_
    self.type_ = type_
    self.old_num_ = old_num_
    self.new_num_ = new_num_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.old_num_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.new_num_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorResourceChange')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 2)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.old_num_ is not None:
      oprot.writeFieldBegin('old_num_', TType.I32, 3)
      oprot.writeI32(self.old_num_)
      oprot.writeFieldEnd()
    if self.new_num_ is not None:
      oprot.writeFieldBegin('new_num_', TType.I32, 4)
      oprot.writeI32(self.new_num_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_ is unset!')
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.old_num_ is None:
      raise TProtocol.TProtocolException(message='Required field old_num_ is unset!')
    if self.new_num_ is None:
      raise TProtocol.TProtocolException(message='Required field new_num_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorRelive:
  """
  Attributes:
   - actor_
   - type_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
    (2, TType.I32, 'type_', None, None, ), # 2
  )

  def __init__(self, actor_=None, type_=None,):
    self.actor_ = actor_
    self.type_ = type_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorRelive')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 2)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_ is unset!')
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventActorFcmStatusChange:
  """
  Attributes:
   - actor_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
  )

  def __init__(self, actor_=None,):
    self.actor_ = actor_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventActorFcmStatusChange')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
