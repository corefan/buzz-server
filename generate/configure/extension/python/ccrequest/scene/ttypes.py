#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import ccentity.direction.ttypes
import ccentity.entity.ttypes
import ccrequest.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class AreaType:
  AREA_CIRCLE = 0
  AREA_SECTOR_QUARTER = 1
  AREA_RAY = 2
  AREA_MAX = 3

  _VALUES_TO_NAMES = {
    0: "AREA_CIRCLE",
    1: "AREA_SECTOR_QUARTER",
    2: "AREA_RAY",
    3: "AREA_MAX",
  }

  _NAMES_TO_VALUES = {
    "AREA_CIRCLE": 0,
    "AREA_SECTOR_QUARTER": 1,
    "AREA_RAY": 2,
    "AREA_MAX": 3,
  }

class SectorRadianType:
  MIN = 0
  QUARTER = 0
  HALF = 1
  MAX = 2

  _VALUES_TO_NAMES = {
    0: "MIN",
    0: "QUARTER",
    1: "HALF",
    2: "MAX",
  }

  _NAMES_TO_VALUES = {
    "MIN": 0,
    "QUARTER": 0,
    "HALF": 1,
    "MAX": 2,
  }

class SceneEntityType:
  ACTOR = 1
  NPC = 2

  _VALUES_TO_NAMES = {
    1: "ACTOR",
    2: "NPC",
  }

  _NAMES_TO_VALUES = {
    "ACTOR": 1,
    "NPC": 2,
  }

class SelectMaskType:
  SELF = 1
  NOT_SELF = 2
  NPC = 16
  ACTOR = 32
  ALIVE = 256
  DEAD = 512
  CAMP_ENEMY = 4096
  CAMP_FRIEND = 8192
  CAMP_NEUTRAL = 16384
  CAMP_NONE = 32768
  TEAM = 65536
  OTHER_TEAM = 131072
  PK_CHECK = 1048576

  _VALUES_TO_NAMES = {
    1: "SELF",
    2: "NOT_SELF",
    16: "NPC",
    32: "ACTOR",
    256: "ALIVE",
    512: "DEAD",
    4096: "CAMP_ENEMY",
    8192: "CAMP_FRIEND",
    16384: "CAMP_NEUTRAL",
    32768: "CAMP_NONE",
    65536: "TEAM",
    131072: "OTHER_TEAM",
    1048576: "PK_CHECK",
  }

  _NAMES_TO_VALUES = {
    "SELF": 1,
    "NOT_SELF": 2,
    "NPC": 16,
    "ACTOR": 32,
    "ALIVE": 256,
    "DEAD": 512,
    "CAMP_ENEMY": 4096,
    "CAMP_FRIEND": 8192,
    "CAMP_NEUTRAL": 16384,
    "CAMP_NONE": 32768,
    "TEAM": 65536,
    "OTHER_TEAM": 131072,
    "PK_CHECK": 1048576,
  }

class MoveResultType:
  SUCCESS = 0
  FAILURE_BLOCK = 1
  FAILURE_ERROR = 2

  _VALUES_TO_NAMES = {
    0: "SUCCESS",
    1: "FAILURE_BLOCK",
    2: "FAILURE_ERROR",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 0,
    "FAILURE_BLOCK": 1,
    "FAILURE_ERROR": 2,
  }

class DayNightStatusType:
  STATUS_MORNING = 0
  STATUS_DAYTIME = 1
  STATUS_EVENING = 2
  STATUS_NIGHT = 3

  _VALUES_TO_NAMES = {
    0: "STATUS_MORNING",
    1: "STATUS_DAYTIME",
    2: "STATUS_EVENING",
    3: "STATUS_NIGHT",
  }

  _NAMES_TO_VALUES = {
    "STATUS_MORNING": 0,
    "STATUS_DAYTIME": 1,
    "STATUS_EVENING": 2,
    "STATUS_NIGHT": 3,
  }

class PKCheckResultType:
  SUCCESS = 0
  ERROR_SAFE_AREA = 1
  ERROR_PK_MODE = 2
  ERROR_ROOKIE_PROTECT = 3
  ERROR_DIE_PROTECT_TIME = 4
  ERROR_ARGS = 5

  _VALUES_TO_NAMES = {
    0: "SUCCESS",
    1: "ERROR_SAFE_AREA",
    2: "ERROR_PK_MODE",
    3: "ERROR_ROOKIE_PROTECT",
    4: "ERROR_DIE_PROTECT_TIME",
    5: "ERROR_ARGS",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 0,
    "ERROR_SAFE_AREA": 1,
    "ERROR_PK_MODE": 2,
    "ERROR_ROOKIE_PROTECT": 3,
    "ERROR_DIE_PROTECT_TIME": 4,
    "ERROR_ARGS": 5,
  }


class RequestSceneGetAroundActors:
  """
  Attributes:
   - type_
   - id_
   - actors_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type_', None, None, ), # 1
    (2, TType.I64, 'id_', None, None, ), # 2
    (3, TType.LIST, 'actors_', (TType.I64,None), None, ), # 3
  )

  def __init__(self, type_=None, id_=None, actors_=None,):
    self.type_ = type_
    self.id_ = id_
    self.actors_ = actors_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.actors_ = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI64();
            self.actors_.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneGetAroundActors')
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 1)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 2)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    if self.actors_ is not None:
      oprot.writeFieldBegin('actors_', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.actors_))
      for iter6 in self.actors_:
        oprot.writeI64(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    if self.actors_ is None:
      raise TProtocol.TProtocolException(message='Required field actors_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneSummonNpc:
  """
  Attributes:
   - scene_
   - template_id_
   - x_
   - y_
   - width_
   - heigth_
   - dir_
   - delay_secs_
   - npc_id_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scene_', None, None, ), # 1
    (2, TType.I32, 'template_id_', None, None, ), # 2
    (3, TType.I32, 'x_', None, None, ), # 3
    (4, TType.I32, 'y_', None, None, ), # 4
    (5, TType.I32, 'width_', None, None, ), # 5
    (6, TType.I32, 'heigth_', None, None, ), # 6
    (7, TType.I32, 'dir_', None, None, ), # 7
    (8, TType.I32, 'delay_secs_', None, 0, ), # 8
    (9, TType.I64, 'npc_id_', None, None, ), # 9
  )

  def __init__(self, scene_=None, template_id_=None, x_=None, y_=None, width_=None, heigth_=None, dir_=None, delay_secs_=thrift_spec[8][4], npc_id_=None,):
    self.scene_ = scene_
    self.template_id_ = template_id_
    self.x_ = x_
    self.y_ = y_
    self.width_ = width_
    self.heigth_ = heigth_
    self.dir_ = dir_
    self.delay_secs_ = delay_secs_
    self.npc_id_ = npc_id_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.template_id_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.x_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.y_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.width_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.heigth_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.dir_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.delay_secs_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.npc_id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneSummonNpc')
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 1)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.template_id_ is not None:
      oprot.writeFieldBegin('template_id_', TType.I32, 2)
      oprot.writeI32(self.template_id_)
      oprot.writeFieldEnd()
    if self.x_ is not None:
      oprot.writeFieldBegin('x_', TType.I32, 3)
      oprot.writeI32(self.x_)
      oprot.writeFieldEnd()
    if self.y_ is not None:
      oprot.writeFieldBegin('y_', TType.I32, 4)
      oprot.writeI32(self.y_)
      oprot.writeFieldEnd()
    if self.width_ is not None:
      oprot.writeFieldBegin('width_', TType.I32, 5)
      oprot.writeI32(self.width_)
      oprot.writeFieldEnd()
    if self.heigth_ is not None:
      oprot.writeFieldBegin('heigth_', TType.I32, 6)
      oprot.writeI32(self.heigth_)
      oprot.writeFieldEnd()
    if self.dir_ is not None:
      oprot.writeFieldBegin('dir_', TType.I32, 7)
      oprot.writeI32(self.dir_)
      oprot.writeFieldEnd()
    if self.delay_secs_ is not None:
      oprot.writeFieldBegin('delay_secs_', TType.I32, 8)
      oprot.writeI32(self.delay_secs_)
      oprot.writeFieldEnd()
    if self.npc_id_ is not None:
      oprot.writeFieldBegin('npc_id_', TType.I64, 9)
      oprot.writeI64(self.npc_id_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    if self.template_id_ is None:
      raise TProtocol.TProtocolException(message='Required field template_id_ is unset!')
    if self.x_ is None:
      raise TProtocol.TProtocolException(message='Required field x_ is unset!')
    if self.y_ is None:
      raise TProtocol.TProtocolException(message='Required field y_ is unset!')
    if self.dir_ is None:
      raise TProtocol.TProtocolException(message='Required field dir_ is unset!')
    if self.delay_secs_ is None:
      raise TProtocol.TProtocolException(message='Required field delay_secs_ is unset!')
    if self.npc_id_ is None:
      raise TProtocol.TProtocolException(message='Required field npc_id_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneClearNpc:
  """
  Attributes:
   - id_
   - delay_secs_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id_', None, None, ), # 1
    (2, TType.I32, 'delay_secs_', None, None, ), # 2
  )

  def __init__(self, id_=None, delay_secs_=None,):
    self.id_ = id_
    self.delay_secs_ = delay_secs_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.delay_secs_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneClearNpc')
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 1)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    if self.delay_secs_ is not None:
      oprot.writeFieldBegin('delay_secs_', TType.I32, 2)
      oprot.writeI32(self.delay_secs_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CircleAreaCondition:
  """
  Attributes:
   - radius_
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'radius_', None, None, ), # 1
  )

  def __init__(self, radius_=None,):
    self.radius_ = radius_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.radius_ = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CircleAreaCondition')
    if self.radius_ is not None:
      oprot.writeFieldBegin('radius_', TType.BYTE, 1)
      oprot.writeByte(self.radius_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.radius_ is None:
      raise TProtocol.TProtocolException(message='Required field radius_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SectorAreaCondition:
  """
  Attributes:
   - radius_
   - dir_
   - radian_
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'radius_', None, None, ), # 1
    (2, TType.I32, 'dir_', None, None, ), # 2
    (3, TType.I32, 'radian_', None, None, ), # 3
  )

  def __init__(self, radius_=None, dir_=None, radian_=None,):
    self.radius_ = radius_
    self.dir_ = dir_
    self.radian_ = radian_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.radius_ = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dir_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.radian_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SectorAreaCondition')
    if self.radius_ is not None:
      oprot.writeFieldBegin('radius_', TType.BYTE, 1)
      oprot.writeByte(self.radius_)
      oprot.writeFieldEnd()
    if self.dir_ is not None:
      oprot.writeFieldBegin('dir_', TType.I32, 2)
      oprot.writeI32(self.dir_)
      oprot.writeFieldEnd()
    if self.radian_ is not None:
      oprot.writeFieldBegin('radian_', TType.I32, 3)
      oprot.writeI32(self.radian_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.radius_ is None:
      raise TProtocol.TProtocolException(message='Required field radius_ is unset!')
    if self.dir_ is None:
      raise TProtocol.TProtocolException(message='Required field dir_ is unset!')
    if self.radian_ is None:
      raise TProtocol.TProtocolException(message='Required field radian_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RayAreaCondition:
  """
  Attributes:
   - width_
   - length_
   - direction_
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'width_', None, None, ), # 1
    (2, TType.BYTE, 'length_', None, None, ), # 2
    (3, TType.I16, 'direction_', None, None, ), # 3
  )

  def __init__(self, width_=None, length_=None, direction_=None,):
    self.width_ = width_
    self.length_ = length_
    self.direction_ = direction_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.width_ = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.length_ = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.direction_ = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RayAreaCondition')
    if self.width_ is not None:
      oprot.writeFieldBegin('width_', TType.BYTE, 1)
      oprot.writeByte(self.width_)
      oprot.writeFieldEnd()
    if self.length_ is not None:
      oprot.writeFieldBegin('length_', TType.BYTE, 2)
      oprot.writeByte(self.length_)
      oprot.writeFieldEnd()
    if self.direction_ is not None:
      oprot.writeFieldBegin('direction_', TType.I16, 3)
      oprot.writeI16(self.direction_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.width_ is None:
      raise TProtocol.TProtocolException(message='Required field width_ is unset!')
    if self.length_ is None:
      raise TProtocol.TProtocolException(message='Required field length_ is unset!')
    if self.direction_ is None:
      raise TProtocol.TProtocolException(message='Required field direction_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AreaRolePair:
  """
  Attributes:
   - type_
   - id_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type_', None, None, ), # 1
    (2, TType.I64, 'id_', None, None, ), # 2
  )

  def __init__(self, type_=None, id_=None,):
    self.type_ = type_
    self.id_ = id_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AreaRolePair')
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 1)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 2)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneSelectTargets:
  """
  Attributes:
   - type_
   - id_
   - area_type_
   - cond_circle_
   - cond_sector_
   - x_
   - y_
   - select_mask_
   - max_count_
   - targets_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type_', None, None, ), # 1
    (2, TType.I64, 'id_', None, None, ), # 2
    (3, TType.I32, 'area_type_', None, None, ), # 3
    (4, TType.STRUCT, 'cond_circle_', (CircleAreaCondition, CircleAreaCondition.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'cond_sector_', (SectorAreaCondition, SectorAreaCondition.thrift_spec), None, ), # 5
    (6, TType.I32, 'x_', None, None, ), # 6
    (7, TType.I32, 'y_', None, None, ), # 7
    (8, TType.I32, 'select_mask_', None, None, ), # 8
    (9, TType.I32, 'max_count_', None, None, ), # 9
    (10, TType.LIST, 'targets_', (TType.STRUCT,(AreaRolePair, AreaRolePair.thrift_spec)), None, ), # 10
  )

  def __init__(self, type_=None, id_=None, area_type_=None, cond_circle_=None, cond_sector_=None, x_=None, y_=None, select_mask_=None, max_count_=None, targets_=None,):
    self.type_ = type_
    self.id_ = id_
    self.area_type_ = area_type_
    self.cond_circle_ = cond_circle_
    self.cond_sector_ = cond_sector_
    self.x_ = x_
    self.y_ = y_
    self.select_mask_ = select_mask_
    self.max_count_ = max_count_
    self.targets_ = targets_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.area_type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cond_circle_ = CircleAreaCondition()
          self.cond_circle_.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.cond_sector_ = SectorAreaCondition()
          self.cond_sector_.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.x_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.y_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.select_mask_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.max_count_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.targets_ = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = AreaRolePair()
            _elem12.read(iprot)
            self.targets_.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneSelectTargets')
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 1)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 2)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    if self.area_type_ is not None:
      oprot.writeFieldBegin('area_type_', TType.I32, 3)
      oprot.writeI32(self.area_type_)
      oprot.writeFieldEnd()
    if self.cond_circle_ is not None:
      oprot.writeFieldBegin('cond_circle_', TType.STRUCT, 4)
      self.cond_circle_.write(oprot)
      oprot.writeFieldEnd()
    if self.cond_sector_ is not None:
      oprot.writeFieldBegin('cond_sector_', TType.STRUCT, 5)
      self.cond_sector_.write(oprot)
      oprot.writeFieldEnd()
    if self.x_ is not None:
      oprot.writeFieldBegin('x_', TType.I32, 6)
      oprot.writeI32(self.x_)
      oprot.writeFieldEnd()
    if self.y_ is not None:
      oprot.writeFieldBegin('y_', TType.I32, 7)
      oprot.writeI32(self.y_)
      oprot.writeFieldEnd()
    if self.select_mask_ is not None:
      oprot.writeFieldBegin('select_mask_', TType.I32, 8)
      oprot.writeI32(self.select_mask_)
      oprot.writeFieldEnd()
    if self.max_count_ is not None:
      oprot.writeFieldBegin('max_count_', TType.I32, 9)
      oprot.writeI32(self.max_count_)
      oprot.writeFieldEnd()
    if self.targets_ is not None:
      oprot.writeFieldBegin('targets_', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.targets_))
      for iter13 in self.targets_:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    if self.area_type_ is None:
      raise TProtocol.TProtocolException(message='Required field area_type_ is unset!')
    if self.x_ is None:
      raise TProtocol.TProtocolException(message='Required field x_ is unset!')
    if self.y_ is None:
      raise TProtocol.TProtocolException(message='Required field y_ is unset!')
    if self.select_mask_ is None:
      raise TProtocol.TProtocolException(message='Required field select_mask_ is unset!')
    if self.max_count_ is None:
      raise TProtocol.TProtocolException(message='Required field max_count_ is unset!')
    if self.targets_ is None:
      raise TProtocol.TProtocolException(message='Required field targets_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneRoleMove:
  """
  Attributes:
   - type_
   - id_
   - dir_
   - result_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type_', None, None, ), # 1
    (2, TType.I64, 'id_', None, None, ), # 2
    (3, TType.I32, 'dir_', None, None, ), # 3
    (4, TType.I32, 'result_', None, None, ), # 4
  )

  def __init__(self, type_=None, id_=None, dir_=None, result_=None,):
    self.type_ = type_
    self.id_ = id_
    self.dir_ = dir_
    self.result_ = result_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.dir_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.result_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneRoleMove')
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 1)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 2)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    if self.dir_ is not None:
      oprot.writeFieldBegin('dir_', TType.I32, 3)
      oprot.writeI32(self.dir_)
      oprot.writeFieldEnd()
    if self.result_ is not None:
      oprot.writeFieldBegin('result_', TType.I32, 4)
      oprot.writeI32(self.result_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    if self.dir_ is None:
      raise TProtocol.TProtocolException(message='Required field dir_ is unset!')
    if self.result_ is None:
      raise TProtocol.TProtocolException(message='Required field result_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneJump:
  """
  Attributes:
   - type_
   - id_
   - map_
   - scene_
   - x_
   - y_
   - result_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type_', None, None, ), # 1
    (2, TType.I64, 'id_', None, None, ), # 2
    (3, TType.I32, 'map_', None, None, ), # 3
    (4, TType.I64, 'scene_', None, None, ), # 4
    (5, TType.I32, 'x_', None, None, ), # 5
    (6, TType.I32, 'y_', None, None, ), # 6
    (7, TType.BOOL, 'result_', None, None, ), # 7
  )

  def __init__(self, type_=None, id_=None, map_=None, scene_=None, x_=None, y_=None, result_=None,):
    self.type_ = type_
    self.id_ = id_
    self.map_ = map_
    self.scene_ = scene_
    self.x_ = x_
    self.y_ = y_
    self.result_ = result_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.map_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.x_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.y_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.result_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneJump')
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 1)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 2)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    if self.map_ is not None:
      oprot.writeFieldBegin('map_', TType.I32, 3)
      oprot.writeI32(self.map_)
      oprot.writeFieldEnd()
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 4)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.x_ is not None:
      oprot.writeFieldBegin('x_', TType.I32, 5)
      oprot.writeI32(self.x_)
      oprot.writeFieldEnd()
    if self.y_ is not None:
      oprot.writeFieldBegin('y_', TType.I32, 6)
      oprot.writeI32(self.y_)
      oprot.writeFieldEnd()
    if self.result_ is not None:
      oprot.writeFieldBegin('result_', TType.BOOL, 7)
      oprot.writeBool(self.result_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    if self.x_ is None:
      raise TProtocol.TProtocolException(message='Required field x_ is unset!')
    if self.y_ is None:
      raise TProtocol.TProtocolException(message='Required field y_ is unset!')
    if self.result_ is None:
      raise TProtocol.TProtocolException(message='Required field result_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneRelocation:
  """
  Attributes:
   - type_
   - id_
   - x_
   - y_
   - result_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type_', None, None, ), # 1
    (2, TType.I64, 'id_', None, None, ), # 2
    (3, TType.I32, 'x_', None, None, ), # 3
    (4, TType.I32, 'y_', None, None, ), # 4
    (5, TType.BOOL, 'result_', None, None, ), # 5
  )

  def __init__(self, type_=None, id_=None, x_=None, y_=None, result_=None,):
    self.type_ = type_
    self.id_ = id_
    self.x_ = x_
    self.y_ = y_
    self.result_ = result_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.x_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.y_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.result_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneRelocation')
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 1)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.id_ is not None:
      oprot.writeFieldBegin('id_', TType.I64, 2)
      oprot.writeI64(self.id_)
      oprot.writeFieldEnd()
    if self.x_ is not None:
      oprot.writeFieldBegin('x_', TType.I32, 3)
      oprot.writeI32(self.x_)
      oprot.writeFieldEnd()
    if self.y_ is not None:
      oprot.writeFieldBegin('y_', TType.I32, 4)
      oprot.writeI32(self.y_)
      oprot.writeFieldEnd()
    if self.result_ is not None:
      oprot.writeFieldBegin('result_', TType.BOOL, 5)
      oprot.writeBool(self.result_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.id_ is None:
      raise TProtocol.TProtocolException(message='Required field id_ is unset!')
    if self.x_ is None:
      raise TProtocol.TProtocolException(message='Required field x_ is unset!')
    if self.y_ is None:
      raise TProtocol.TProtocolException(message='Required field y_ is unset!')
    if self.result_ is None:
      raise TProtocol.TProtocolException(message='Required field result_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneDayNightInfo:
  """
  Attributes:
   - scene_
   - status_
   - aoi_coe_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scene_', None, None, ), # 1
    (2, TType.I32, 'status_', None, None, ), # 2
    (3, TType.I32, 'aoi_coe_', None, None, ), # 3
  )

  def __init__(self, scene_=None, status_=None, aoi_coe_=None,):
    self.scene_ = scene_
    self.status_ = status_
    self.aoi_coe_ = aoi_coe_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.aoi_coe_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneDayNightInfo')
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 1)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.status_ is not None:
      oprot.writeFieldBegin('status_', TType.I32, 2)
      oprot.writeI32(self.status_)
      oprot.writeFieldEnd()
    if self.aoi_coe_ is not None:
      oprot.writeFieldBegin('aoi_coe_', TType.I32, 3)
      oprot.writeI32(self.aoi_coe_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    if self.status_ is None:
      raise TProtocol.TProtocolException(message='Required field status_ is unset!')
    if self.aoi_coe_ is None:
      raise TProtocol.TProtocolException(message='Required field aoi_coe_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneRouter:
  """
  Attributes:
   - scene_
   - src_x_
   - src_y_
   - dest_x_
   - dest_y_
   - dest_radius_
   - max_path_
   - paths_
   - result_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scene_', None, None, ), # 1
    (2, TType.I32, 'src_x_', None, None, ), # 2
    (3, TType.I32, 'src_y_', None, None, ), # 3
    (4, TType.I32, 'dest_x_', None, None, ), # 4
    (5, TType.I32, 'dest_y_', None, None, ), # 5
    (6, TType.I32, 'dest_radius_', None, None, ), # 6
    (7, TType.I16, 'max_path_', None, None, ), # 7
    (8, TType.LIST, 'paths_', (TType.I32,None), None, ), # 8
    (9, TType.BOOL, 'result_', None, None, ), # 9
  )

  def __init__(self, scene_=None, src_x_=None, src_y_=None, dest_x_=None, dest_y_=None, dest_radius_=None, max_path_=None, paths_=None, result_=None,):
    self.scene_ = scene_
    self.src_x_ = src_x_
    self.src_y_ = src_y_
    self.dest_x_ = dest_x_
    self.dest_y_ = dest_y_
    self.dest_radius_ = dest_radius_
    self.max_path_ = max_path_
    self.paths_ = paths_
    self.result_ = result_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.src_x_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.src_y_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.dest_x_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.dest_y_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.dest_radius_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.max_path_ = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.paths_ = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readI32();
            self.paths_.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.result_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneRouter')
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 1)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.src_x_ is not None:
      oprot.writeFieldBegin('src_x_', TType.I32, 2)
      oprot.writeI32(self.src_x_)
      oprot.writeFieldEnd()
    if self.src_y_ is not None:
      oprot.writeFieldBegin('src_y_', TType.I32, 3)
      oprot.writeI32(self.src_y_)
      oprot.writeFieldEnd()
    if self.dest_x_ is not None:
      oprot.writeFieldBegin('dest_x_', TType.I32, 4)
      oprot.writeI32(self.dest_x_)
      oprot.writeFieldEnd()
    if self.dest_y_ is not None:
      oprot.writeFieldBegin('dest_y_', TType.I32, 5)
      oprot.writeI32(self.dest_y_)
      oprot.writeFieldEnd()
    if self.dest_radius_ is not None:
      oprot.writeFieldBegin('dest_radius_', TType.I32, 6)
      oprot.writeI32(self.dest_radius_)
      oprot.writeFieldEnd()
    if self.max_path_ is not None:
      oprot.writeFieldBegin('max_path_', TType.I16, 7)
      oprot.writeI16(self.max_path_)
      oprot.writeFieldEnd()
    if self.paths_ is not None:
      oprot.writeFieldBegin('paths_', TType.LIST, 8)
      oprot.writeListBegin(TType.I32, len(self.paths_))
      for iter20 in self.paths_:
        oprot.writeI32(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.result_ is not None:
      oprot.writeFieldBegin('result_', TType.BOOL, 9)
      oprot.writeBool(self.result_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    if self.src_x_ is None:
      raise TProtocol.TProtocolException(message='Required field src_x_ is unset!')
    if self.src_y_ is None:
      raise TProtocol.TProtocolException(message='Required field src_y_ is unset!')
    if self.dest_x_ is None:
      raise TProtocol.TProtocolException(message='Required field dest_x_ is unset!')
    if self.dest_y_ is None:
      raise TProtocol.TProtocolException(message='Required field dest_y_ is unset!')
    if self.dest_radius_ is None:
      raise TProtocol.TProtocolException(message='Required field dest_radius_ is unset!')
    if self.max_path_ is None:
      raise TProtocol.TProtocolException(message='Required field max_path_ is unset!')
    if self.paths_ is None:
      raise TProtocol.TProtocolException(message='Required field paths_ is unset!')
    if self.result_ is None:
      raise TProtocol.TProtocolException(message='Required field result_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestScenePKInfo:
  """
  Attributes:
   - scene_
   - rookie_protect_
   - ban_change_pk_mode_
   - die_protect_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scene_', None, None, ), # 1
    (2, TType.BOOL, 'rookie_protect_', None, None, ), # 2
    (3, TType.BOOL, 'ban_change_pk_mode_', None, None, ), # 3
    (4, TType.BOOL, 'die_protect_', None, None, ), # 4
  )

  def __init__(self, scene_=None, rookie_protect_=None, ban_change_pk_mode_=None, die_protect_=None,):
    self.scene_ = scene_
    self.rookie_protect_ = rookie_protect_
    self.ban_change_pk_mode_ = ban_change_pk_mode_
    self.die_protect_ = die_protect_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.rookie_protect_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.ban_change_pk_mode_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.die_protect_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestScenePKInfo')
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 1)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.rookie_protect_ is not None:
      oprot.writeFieldBegin('rookie_protect_', TType.BOOL, 2)
      oprot.writeBool(self.rookie_protect_)
      oprot.writeFieldEnd()
    if self.ban_change_pk_mode_ is not None:
      oprot.writeFieldBegin('ban_change_pk_mode_', TType.BOOL, 3)
      oprot.writeBool(self.ban_change_pk_mode_)
      oprot.writeFieldEnd()
    if self.die_protect_ is not None:
      oprot.writeFieldBegin('die_protect_', TType.BOOL, 4)
      oprot.writeBool(self.die_protect_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    if self.rookie_protect_ is None:
      raise TProtocol.TProtocolException(message='Required field rookie_protect_ is unset!')
    if self.ban_change_pk_mode_ is None:
      raise TProtocol.TProtocolException(message='Required field ban_change_pk_mode_ is unset!')
    if self.die_protect_ is None:
      raise TProtocol.TProtocolException(message='Required field die_protect_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneIsSafe:
  """
  Attributes:
   - scene_
   - x_
   - y_
   - is_safe_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scene_', None, None, ), # 1
    (2, TType.I32, 'x_', None, None, ), # 2
    (3, TType.I32, 'y_', None, None, ), # 3
    (4, TType.BOOL, 'is_safe_', None, None, ), # 4
  )

  def __init__(self, scene_=None, x_=None, y_=None, is_safe_=None,):
    self.scene_ = scene_
    self.x_ = x_
    self.y_ = y_
    self.is_safe_ = is_safe_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.x_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.y_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_safe_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneIsSafe')
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 1)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.x_ is not None:
      oprot.writeFieldBegin('x_', TType.I32, 2)
      oprot.writeI32(self.x_)
      oprot.writeFieldEnd()
    if self.y_ is not None:
      oprot.writeFieldBegin('y_', TType.I32, 3)
      oprot.writeI32(self.y_)
      oprot.writeFieldEnd()
    if self.is_safe_ is not None:
      oprot.writeFieldBegin('is_safe_', TType.BOOL, 4)
      oprot.writeBool(self.is_safe_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    if self.x_ is None:
      raise TProtocol.TProtocolException(message='Required field x_ is unset!')
    if self.y_ is None:
      raise TProtocol.TProtocolException(message='Required field y_ is unset!')
    if self.is_safe_ is None:
      raise TProtocol.TProtocolException(message='Required field is_safe_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestScenePKCheck:
  """
  Attributes:
   - src_id_
   - dest_id_
   - result_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'src_id_', None, None, ), # 1
    (2, TType.I64, 'dest_id_', None, None, ), # 2
    (3, TType.I32, 'result_', None, None, ), # 3
  )

  def __init__(self, src_id_=None, dest_id_=None, result_=None,):
    self.src_id_ = src_id_
    self.dest_id_ = dest_id_
    self.result_ = result_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.src_id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.dest_id_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.result_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestScenePKCheck')
    if self.src_id_ is not None:
      oprot.writeFieldBegin('src_id_', TType.I64, 1)
      oprot.writeI64(self.src_id_)
      oprot.writeFieldEnd()
    if self.dest_id_ is not None:
      oprot.writeFieldBegin('dest_id_', TType.I64, 2)
      oprot.writeI64(self.dest_id_)
      oprot.writeFieldEnd()
    if self.result_ is not None:
      oprot.writeFieldBegin('result_', TType.I32, 3)
      oprot.writeI32(self.result_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.src_id_ is None:
      raise TProtocol.TProtocolException(message='Required field src_id_ is unset!')
    if self.dest_id_ is None:
      raise TProtocol.TProtocolException(message='Required field dest_id_ is unset!')
    if self.result_ is None:
      raise TProtocol.TProtocolException(message='Required field result_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneActorBroadcast:
  """
  Attributes:
   - type_
   - message_
   - scene_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type_', None, None, ), # 1
    (2, TType.STRING, 'message_', None, None, ), # 2
    (3, TType.I64, 'scene_', None, None, ), # 3
  )

  def __init__(self, type_=None, message_=None, scene_=None,):
    self.type_ = type_
    self.message_ = message_
    self.scene_ = scene_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.message_ = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneActorBroadcast')
    if self.type_ is not None:
      oprot.writeFieldBegin('type_', TType.I32, 1)
      oprot.writeI32(self.type_)
      oprot.writeFieldEnd()
    if self.message_ is not None:
      oprot.writeFieldBegin('message_', TType.STRING, 2)
      oprot.writeString(self.message_)
      oprot.writeFieldEnd()
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 3)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type_ is None:
      raise TProtocol.TProtocolException(message='Required field type_ is unset!')
    if self.message_ is None:
      raise TProtocol.TProtocolException(message='Required field message_ is unset!')
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneCreateMap:
  """
  Attributes:
   - map_
   - scene_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'map_', None, None, ), # 1
    (2, TType.I64, 'scene_', None, None, ), # 2
  )

  def __init__(self, map_=None, scene_=None,):
    self.map_ = map_
    self.scene_ = scene_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.map_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneCreateMap')
    if self.map_ is not None:
      oprot.writeFieldBegin('map_', TType.I32, 1)
      oprot.writeI32(self.map_)
      oprot.writeFieldEnd()
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 2)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.map_ is None:
      raise TProtocol.TProtocolException(message='Required field map_ is unset!')
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneDestoryMap:
  """
  Attributes:
   - scene_
   - result_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scene_', None, None, ), # 1
    (2, TType.BOOL, 'result_', None, None, ), # 2
  )

  def __init__(self, scene_=None, result_=None,):
    self.scene_ = scene_
    self.result_ = result_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.result_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneDestoryMap')
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 1)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.result_ is not None:
      oprot.writeFieldBegin('result_', TType.BOOL, 2)
      oprot.writeBool(self.result_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    if self.result_ is None:
      raise TProtocol.TProtocolException(message='Required field result_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneClearAllNpc:
  """
  Attributes:
   - scene_
   - delay_secs_
   - force_clear_reborn_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scene_', None, None, ), # 1
    (2, TType.I32, 'delay_secs_', None, 0, ), # 2
    (3, TType.BOOL, 'force_clear_reborn_', None, False, ), # 3
  )

  def __init__(self, scene_=None, delay_secs_=thrift_spec[2][4], force_clear_reborn_=thrift_spec[3][4],):
    self.scene_ = scene_
    self.delay_secs_ = delay_secs_
    self.force_clear_reborn_ = force_clear_reborn_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.delay_secs_ = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.force_clear_reborn_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneClearAllNpc')
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 1)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.delay_secs_ is not None:
      oprot.writeFieldBegin('delay_secs_', TType.I32, 2)
      oprot.writeI32(self.delay_secs_)
      oprot.writeFieldEnd()
    if self.force_clear_reborn_ is not None:
      oprot.writeFieldBegin('force_clear_reborn_', TType.BOOL, 3)
      oprot.writeBool(self.force_clear_reborn_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    if self.delay_secs_ is None:
      raise TProtocol.TProtocolException(message='Required field delay_secs_ is unset!')
    if self.force_clear_reborn_ is None:
      raise TProtocol.TProtocolException(message='Required field force_clear_reborn_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneRevive:
  """
  Attributes:
   - actor_
   - stay_revive_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'actor_', None, None, ), # 1
    (2, TType.BOOL, 'stay_revive_', None, None, ), # 2
  )

  def __init__(self, actor_=None, stay_revive_=None,):
    self.actor_ = actor_
    self.stay_revive_ = stay_revive_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.actor_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.stay_revive_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneRevive')
    if self.actor_ is not None:
      oprot.writeFieldBegin('actor_', TType.I64, 1)
      oprot.writeI64(self.actor_)
      oprot.writeFieldEnd()
    if self.stay_revive_ is not None:
      oprot.writeFieldBegin('stay_revive_', TType.BOOL, 2)
      oprot.writeBool(self.stay_revive_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.actor_ is None:
      raise TProtocol.TProtocolException(message='Required field actor_ is unset!')
    if self.stay_revive_ is None:
      raise TProtocol.TProtocolException(message='Required field stay_revive_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneForbidDropItem:
  """
  Attributes:
   - npcs_
   - forbid_
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'npcs_', (TType.I64,None), None, ), # 1
    (2, TType.BOOL, 'forbid_', None, None, ), # 2
  )

  def __init__(self, npcs_=None, forbid_=None,):
    self.npcs_ = npcs_
    self.forbid_ = forbid_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.npcs_ = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readI64();
            self.npcs_.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.forbid_ = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneForbidDropItem')
    if self.npcs_ is not None:
      oprot.writeFieldBegin('npcs_', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.npcs_))
      for iter27 in self.npcs_:
        oprot.writeI64(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.forbid_ is not None:
      oprot.writeFieldBegin('forbid_', TType.BOOL, 2)
      oprot.writeBool(self.forbid_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.npcs_ is None:
      raise TProtocol.TProtocolException(message='Required field npcs_ is unset!')
    if self.forbid_ is None:
      raise TProtocol.TProtocolException(message='Required field forbid_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestSceneGetNpcs:
  """
  Attributes:
   - scene_
   - npcs_
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scene_', None, None, ), # 1
    (2, TType.LIST, 'npcs_', (TType.I64,None), None, ), # 2
  )

  def __init__(self, scene_=None, npcs_=None,):
    self.scene_ = scene_
    self.npcs_ = npcs_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scene_ = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.npcs_ = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readI64();
            self.npcs_.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestSceneGetNpcs')
    if self.scene_ is not None:
      oprot.writeFieldBegin('scene_', TType.I64, 1)
      oprot.writeI64(self.scene_)
      oprot.writeFieldEnd()
    if self.npcs_ is not None:
      oprot.writeFieldBegin('npcs_', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.npcs_))
      for iter34 in self.npcs_:
        oprot.writeI64(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scene_ is None:
      raise TProtocol.TProtocolException(message='Required field scene_ is unset!')
    if self.npcs_ is None:
      raise TProtocol.TProtocolException(message='Required field npcs_ is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
