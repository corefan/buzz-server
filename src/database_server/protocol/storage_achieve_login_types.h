/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef storage_achieve_login_TYPES_H
#define storage_achieve_login_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace database { namespace protocol {

struct AchieveField {
  enum type {
    ACHIEVE_ID = 0,
    FLAG = 1,
    CONDITION1_PARAM1 = 2,
    CONDITION1_PARAM2 = 3,
    CONDITION1_VALUE = 4,
    CONDITION2_PARAM1 = 5,
    CONDITION2_PARAM2 = 6,
    CONDITION2_VALUE = 7,
    FINISH_TIME = 8,
    MAX = 9
  };
};

extern const std::map<int, const char*> _AchieveField_VALUES_TO_NAMES;

struct AchieveLoginResult {
  enum type {
    SUCCESS = 0,
    ERROR_INEXIST = 1,
    ERROR_UNKNOWN = 2,
    MAX = 3
  };
};

extern const std::map<int, const char*> _AchieveLoginResult_VALUES_TO_NAMES;

struct AchieveFlag {
  enum type {
    DEL = 0,
    ACTIVE = 1,
    FINISH = 2
  };
};

extern const std::map<int, const char*> _AchieveFlag_VALUES_TO_NAMES;


class StorageAchieveField {
 public:

  static const char* ascii_fingerprint; // = "027E159CFA8AC9DDF61E609145301D49";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0x7E,0x15,0x9C,0xFA,0x8A,0xC9,0xDD,0xF6,0x1E,0x60,0x91,0x45,0x30,0x1D,0x49};

  StorageAchieveField() : achieve_id_(0), condition1_param1_(0), condition1_param2_(0), condition1_value_(0), condition2_param1_(0), condition2_param2_(0), condition2_value_(0), finish_time_(0) {
  }

  virtual ~StorageAchieveField() throw() {}

  int32_t achieve_id_;
  int32_t condition1_param1_;
  int32_t condition1_param2_;
  int32_t condition1_value_;
  int32_t condition2_param1_;
  int32_t condition2_param2_;
  int32_t condition2_value_;
  int64_t finish_time_;

  void __set_achieve_id_(const int32_t val) {
    achieve_id_ = val;
  }

  void __set_condition1_param1_(const int32_t val) {
    condition1_param1_ = val;
  }

  void __set_condition1_param2_(const int32_t val) {
    condition1_param2_ = val;
  }

  void __set_condition1_value_(const int32_t val) {
    condition1_value_ = val;
  }

  void __set_condition2_param1_(const int32_t val) {
    condition2_param1_ = val;
  }

  void __set_condition2_param2_(const int32_t val) {
    condition2_param2_ = val;
  }

  void __set_condition2_value_(const int32_t val) {
    condition2_value_ = val;
  }

  void __set_finish_time_(const int64_t val) {
    finish_time_ = val;
  }

  bool operator == (const StorageAchieveField & rhs) const
  {
    if (!(achieve_id_ == rhs.achieve_id_))
      return false;
    if (!(condition1_param1_ == rhs.condition1_param1_))
      return false;
    if (!(condition1_param2_ == rhs.condition1_param2_))
      return false;
    if (!(condition1_value_ == rhs.condition1_value_))
      return false;
    if (!(condition2_param1_ == rhs.condition2_param1_))
      return false;
    if (!(condition2_param2_ == rhs.condition2_param2_))
      return false;
    if (!(condition2_value_ == rhs.condition2_value_))
      return false;
    if (!(finish_time_ == rhs.finish_time_))
      return false;
    return true;
  }
  bool operator != (const StorageAchieveField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageAchieveField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageAchieveField &a, StorageAchieveField &b);


class StorageAchieveFinishField {
 public:

  static const char* ascii_fingerprint; // = "9C2A05F173B50306037BDE9AE30E1B99";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0x2A,0x05,0xF1,0x73,0xB5,0x03,0x06,0x03,0x7B,0xDE,0x9A,0xE3,0x0E,0x1B,0x99};

  StorageAchieveFinishField() : achieve_id_(0), finish_time_(0) {
  }

  virtual ~StorageAchieveFinishField() throw() {}

  int32_t achieve_id_;
  int64_t finish_time_;

  void __set_achieve_id_(const int32_t val) {
    achieve_id_ = val;
  }

  void __set_finish_time_(const int64_t val) {
    finish_time_ = val;
  }

  bool operator == (const StorageAchieveFinishField & rhs) const
  {
    if (!(achieve_id_ == rhs.achieve_id_))
      return false;
    if (!(finish_time_ == rhs.finish_time_))
      return false;
    return true;
  }
  bool operator != (const StorageAchieveFinishField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageAchieveFinishField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageAchieveFinishField &a, StorageAchieveFinishField &b);


class StorageAchieveLoginRequest {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  StorageAchieveLoginRequest() : actor_(0) {
  }

  virtual ~StorageAchieveLoginRequest() throw() {}

  int64_t actor_;

  void __set_actor_(const int64_t val) {
    actor_ = val;
  }

  bool operator == (const StorageAchieveLoginRequest & rhs) const
  {
    if (!(actor_ == rhs.actor_))
      return false;
    return true;
  }
  bool operator != (const StorageAchieveLoginRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageAchieveLoginRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageAchieveLoginRequest &a, StorageAchieveLoginRequest &b);


class StorageAchieveLoginResponse {
 public:

  static const char* ascii_fingerprint; // = "0881C54FE106022985C13A9E5E482908";
  static const uint8_t binary_fingerprint[16]; // = {0x08,0x81,0xC5,0x4F,0xE1,0x06,0x02,0x29,0x85,0xC1,0x3A,0x9E,0x5E,0x48,0x29,0x08};

  StorageAchieveLoginResponse() : actor_(0), result_((AchieveLoginResult::type)0) {
  }

  virtual ~StorageAchieveLoginResponse() throw() {}

  int64_t actor_;
  std::vector<StorageAchieveField>  achieves_;
  std::vector<StorageAchieveFinishField>  finish_achieves_;
  AchieveLoginResult::type result_;

  void __set_actor_(const int64_t val) {
    actor_ = val;
  }

  void __set_achieves_(const std::vector<StorageAchieveField> & val) {
    achieves_ = val;
  }

  void __set_finish_achieves_(const std::vector<StorageAchieveFinishField> & val) {
    finish_achieves_ = val;
  }

  void __set_result_(const AchieveLoginResult::type val) {
    result_ = val;
  }

  bool operator == (const StorageAchieveLoginResponse & rhs) const
  {
    if (!(actor_ == rhs.actor_))
      return false;
    if (!(achieves_ == rhs.achieves_))
      return false;
    if (!(finish_achieves_ == rhs.finish_achieves_))
      return false;
    if (!(result_ == rhs.result_))
      return false;
    return true;
  }
  bool operator != (const StorageAchieveLoginResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageAchieveLoginResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageAchieveLoginResponse &a, StorageAchieveLoginResponse &b);

}} // namespace

#endif
