/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef storage_task_login_TYPES_H
#define storage_task_login_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace database { namespace protocol {

struct TaskField {
  enum type {
    TASK = 0,
    FLAG = 1,
    COND_TYPE1 = 2,
    VAR1 = 3,
    VALUE1 = 4,
    COND_TYPE2 = 5,
    VAR2 = 6,
    VALUE2 = 7,
    COND_TYPE3 = 8,
    VAR3 = 9,
    VALUE3 = 10,
    TASK_TYPE = 11,
    MAX = 12
  };
};

extern const std::map<int, const char*> _TaskField_VALUES_TO_NAMES;

struct TaskLoginResult {
  enum type {
    SUCCESS = 0,
    ERROR_UNKNOWN = 1
  };
};

extern const std::map<int, const char*> _TaskLoginResult_VALUES_TO_NAMES;

struct TaskFlag {
  enum type {
    NOT_EXIST = 0,
    ACTIVE = 1,
    FINISHED = 2,
    MAX = 3
  };
};

extern const std::map<int, const char*> _TaskFlag_VALUES_TO_NAMES;


class StorageTaskField {
 public:

  static const char* ascii_fingerprint; // = "C9B09257039E1A6FA9A9AEB247AF4699";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0xB0,0x92,0x57,0x03,0x9E,0x1A,0x6F,0xA9,0xA9,0xAE,0xB2,0x47,0xAF,0x46,0x99};

  StorageTaskField() : task_(0), flag_(0), cond_type1_(0), var1_(0), value1_(0), cond_type2_(0), var2_(0), value2_(0), cond_type3_(0), var3_(0), value3_(0), task_type_(0) {
  }

  virtual ~StorageTaskField() throw() {}

  int32_t task_;
  int8_t flag_;
  int8_t cond_type1_;
  int32_t var1_;
  int32_t value1_;
  int8_t cond_type2_;
  int32_t var2_;
  int32_t value2_;
  int8_t cond_type3_;
  int32_t var3_;
  int32_t value3_;
  int8_t task_type_;

  void __set_task_(const int32_t val) {
    task_ = val;
  }

  void __set_flag_(const int8_t val) {
    flag_ = val;
  }

  void __set_cond_type1_(const int8_t val) {
    cond_type1_ = val;
  }

  void __set_var1_(const int32_t val) {
    var1_ = val;
  }

  void __set_value1_(const int32_t val) {
    value1_ = val;
  }

  void __set_cond_type2_(const int8_t val) {
    cond_type2_ = val;
  }

  void __set_var2_(const int32_t val) {
    var2_ = val;
  }

  void __set_value2_(const int32_t val) {
    value2_ = val;
  }

  void __set_cond_type3_(const int8_t val) {
    cond_type3_ = val;
  }

  void __set_var3_(const int32_t val) {
    var3_ = val;
  }

  void __set_value3_(const int32_t val) {
    value3_ = val;
  }

  void __set_task_type_(const int8_t val) {
    task_type_ = val;
  }

  bool operator == (const StorageTaskField & rhs) const
  {
    if (!(task_ == rhs.task_))
      return false;
    if (!(flag_ == rhs.flag_))
      return false;
    if (!(cond_type1_ == rhs.cond_type1_))
      return false;
    if (!(var1_ == rhs.var1_))
      return false;
    if (!(value1_ == rhs.value1_))
      return false;
    if (!(cond_type2_ == rhs.cond_type2_))
      return false;
    if (!(var2_ == rhs.var2_))
      return false;
    if (!(value2_ == rhs.value2_))
      return false;
    if (!(cond_type3_ == rhs.cond_type3_))
      return false;
    if (!(var3_ == rhs.var3_))
      return false;
    if (!(value3_ == rhs.value3_))
      return false;
    if (!(task_type_ == rhs.task_type_))
      return false;
    return true;
  }
  bool operator != (const StorageTaskField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageTaskField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageTaskField &a, StorageTaskField &b);


class StorageTaskFinish {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  StorageTaskFinish() : task_id_(0), type_(0) {
  }

  virtual ~StorageTaskFinish() throw() {}

  int32_t task_id_;
  int32_t type_;

  void __set_task_id_(const int32_t val) {
    task_id_ = val;
  }

  void __set_type_(const int32_t val) {
    type_ = val;
  }

  bool operator == (const StorageTaskFinish & rhs) const
  {
    if (!(task_id_ == rhs.task_id_))
      return false;
    if (!(type_ == rhs.type_))
      return false;
    return true;
  }
  bool operator != (const StorageTaskFinish &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageTaskFinish & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageTaskFinish &a, StorageTaskFinish &b);


class StorageTaskLoginRequest {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  StorageTaskLoginRequest() : actor_id_(0) {
  }

  virtual ~StorageTaskLoginRequest() throw() {}

  int64_t actor_id_;

  void __set_actor_id_(const int64_t val) {
    actor_id_ = val;
  }

  bool operator == (const StorageTaskLoginRequest & rhs) const
  {
    if (!(actor_id_ == rhs.actor_id_))
      return false;
    return true;
  }
  bool operator != (const StorageTaskLoginRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageTaskLoginRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageTaskLoginRequest &a, StorageTaskLoginRequest &b);


class StorageTaskLoginResponse {
 public:

  static const char* ascii_fingerprint; // = "4DE3A2BD02A5C38C350F83A882ADEF0B";
  static const uint8_t binary_fingerprint[16]; // = {0x4D,0xE3,0xA2,0xBD,0x02,0xA5,0xC3,0x8C,0x35,0x0F,0x83,0xA8,0x82,0xAD,0xEF,0x0B};

  StorageTaskLoginResponse() : result_((TaskLoginResult::type)0) {
  }

  virtual ~StorageTaskLoginResponse() throw() {}

  TaskLoginResult::type result_;
  std::vector<StorageTaskField>  actives_;
  std::vector<StorageTaskFinish>  finishes_;

  void __set_result_(const TaskLoginResult::type val) {
    result_ = val;
  }

  void __set_actives_(const std::vector<StorageTaskField> & val) {
    actives_ = val;
  }

  void __set_finishes_(const std::vector<StorageTaskFinish> & val) {
    finishes_ = val;
  }

  bool operator == (const StorageTaskLoginResponse & rhs) const
  {
    if (!(result_ == rhs.result_))
      return false;
    if (!(actives_ == rhs.actives_))
      return false;
    if (!(finishes_ == rhs.finishes_))
      return false;
    return true;
  }
  bool operator != (const StorageTaskLoginResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageTaskLoginResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageTaskLoginResponse &a, StorageTaskLoginResponse &b);

}} // namespace

#endif
