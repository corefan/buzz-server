/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "gateway_mall_protocol_types.h"

#include <algorithm>

namespace gateway { namespace protocol {

const char* MessageMallBuyRequest::ascii_fingerprint = "B94D7C521D8FC4C01D1032D514A8E471";
const uint8_t MessageMallBuyRequest::binary_fingerprint[16] = {0xB9,0x4D,0x7C,0x52,0x1D,0x8F,0xC4,0xC0,0x1D,0x10,0x32,0xD5,0x14,0xA8,0xE4,0x71};

uint32_t MessageMallBuyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_shop_type_ = false;
  bool isset_tab_ = false;
  bool isset_pos_ = false;
  bool isset_use_type_ = false;
  bool isset_num_ = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->shop_type_ = ( ::entity::MallTreasureType::type)ecast0;
          isset_shop_type_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->tab_);
          isset_tab_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->pos_);
          isset_pos_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->use_type_ = ( ::entity::MallUseType::type)ecast1;
          isset_use_type_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_);
          isset_num_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_shop_type_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tab_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pos_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_use_type_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MessageMallBuyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MessageMallBuyRequest");

  xfer += oprot->writeFieldBegin("shop_type_", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->shop_type_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tab_", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->tab_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos_", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->pos_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_type_", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->use_type_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->num_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MessageMallBuyRequest &a, MessageMallBuyRequest &b) {
  using ::std::swap;
  swap(a.shop_type_, b.shop_type_);
  swap(a.tab_, b.tab_);
  swap(a.pos_, b.pos_);
  swap(a.use_type_, b.use_type_);
  swap(a.num_, b.num_);
}

const char* MessageMallBuyResponse::ascii_fingerprint = "862C33AD77120C5F65582C09FC56AFEF";
const uint8_t MessageMallBuyResponse::binary_fingerprint[16] = {0x86,0x2C,0x33,0xAD,0x77,0x12,0x0C,0x5F,0x65,0x58,0x2C,0x09,0xFC,0x56,0xAF,0xEF};

uint32_t MessageMallBuyResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_use_type_ = false;
  bool isset_id_ = false;
  bool isset_num_ = false;
  bool isset_shop_type_ = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->use_type_ = ( ::entity::MallUseType::type)ecast2;
          isset_use_type_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id_);
          isset_id_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_);
          isset_num_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->shop_type_ = ( ::entity::MallTreasureType::type)ecast3;
          isset_shop_type_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_use_type_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_shop_type_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MessageMallBuyResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MessageMallBuyResponse");

  xfer += oprot->writeFieldBegin("use_type_", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->use_type_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id_", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->id_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->num_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shop_type_", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->shop_type_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MessageMallBuyResponse &a, MessageMallBuyResponse &b) {
  using ::std::swap;
  swap(a.use_type_, b.use_type_);
  swap(a.id_, b.id_);
  swap(a.num_, b.num_);
  swap(a.shop_type_, b.shop_type_);
}

const char* MessageMallSynchronize::ascii_fingerprint = "92439E0DEE83A2751834B263FA07411D";
const uint8_t MessageMallSynchronize::binary_fingerprint[16] = {0x92,0x43,0x9E,0x0D,0xEE,0x83,0xA2,0x75,0x18,0x34,0xB2,0x63,0xFA,0x07,0x41,0x1D};

uint32_t MessageMallSynchronize::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cells_ = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells_.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->cells_.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->cells_[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cells_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cells_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MessageMallSynchronize::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MessageMallSynchronize");

  xfer += oprot->writeFieldBegin("cells_", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells_.size()));
    std::vector< ::entity::MallTreasureCell> ::const_iterator _iter9;
    for (_iter9 = this->cells_.begin(); _iter9 != this->cells_.end(); ++_iter9)
    {
      xfer += (*_iter9).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MessageMallSynchronize &a, MessageMallSynchronize &b) {
  using ::std::swap;
  swap(a.cells_, b.cells_);
}

const char* MessageMallItemBuyNumInitialize::ascii_fingerprint = "2F9B604E54610FE2F0CD6865A57000F9";
const uint8_t MessageMallItemBuyNumInitialize::binary_fingerprint[16] = {0x2F,0x9B,0x60,0x4E,0x54,0x61,0x0F,0xE2,0xF0,0xCD,0x68,0x65,0xA5,0x70,0x00,0xF9};

uint32_t MessageMallItemBuyNumInitialize::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_buys_ = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->buys_.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->buys_.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->buys_[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_buys_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_buys_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MessageMallItemBuyNumInitialize::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MessageMallItemBuyNumInitialize");

  xfer += oprot->writeFieldBegin("buys_", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->buys_.size()));
    std::vector< ::entity::MallReasureBuyNum> ::const_iterator _iter15;
    for (_iter15 = this->buys_.begin(); _iter15 != this->buys_.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MessageMallItemBuyNumInitialize &a, MessageMallItemBuyNumInitialize &b) {
  using ::std::swap;
  swap(a.buys_, b.buys_);
}

}} // namespace
