/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef item_TYPES_H
#define item_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace entity {

struct ItemType {
  enum type {
    EQUIPMENT = 0,
    MEDICINE = 1,
    CARD = 2,
    MATERIAL = 3,
    TASK = 4,
    MAX = 5
  };
};

extern const std::map<int, const char*> _ItemType_VALUES_TO_NAMES;

struct EquipmentType {
  enum type {
    MIN = 0,
    WEAPONS = 0,
    HAT = 1,
    CLOTHES = 2,
    ARM = 3,
    BELT = 4,
    TROUSERS = 5,
    SHOES = 6,
    RING = 7,
    NECKLACE = 8,
    ACCESORY = 9,
    MAX = 10
  };
};

extern const std::map<int, const char*> _EquipmentType_VALUES_TO_NAMES;

struct MedicineType {
  enum type {
    MIN = 0,
    MEDICINE = 0,
    BUFF = 1,
    SOUL = 2,
    MAX = 3
  };
};

extern const std::map<int, const char*> _MedicineType_VALUES_TO_NAMES;

struct MaterialType {
  enum type {
    MIN = 0,
    EQUIP_INTENSIFY = 0,
    INLAY = 1,
    SLOTTING = 2,
    REFINE = 3,
    PROMOTION = 4,
    HORSE_INTENSIFY = 5,
    HORSE_UNREAL = 6,
    SOUL_STONE = 7,
    RUNE = 13,
    MAX = 14
  };
};

extern const std::map<int, const char*> _MaterialType_VALUES_TO_NAMES;

struct CardType {
  enum type {
    MIN = 0,
    MAX = 1
  };
};

extern const std::map<int, const char*> _CardType_VALUES_TO_NAMES;

struct TaskItemType {
  enum type {
    MIN = 0,
    MAX = 1
  };
};

extern const std::map<int, const char*> _TaskItemType_VALUES_TO_NAMES;

struct ItemContainerType {
  enum type {
    PACKET = 0,
    EQUIP = 1,
    SHOP = 2,
    STORAGE = 3,
    TREASURE = 4,
    MAX = 5
  };
};

extern const std::map<int, const char*> _ItemContainerType_VALUES_TO_NAMES;

struct ItemTargetType {
  enum type {
    SELF = 0,
    OTHER_ONE = 1
  };
};

extern const std::map<int, const char*> _ItemTargetType_VALUES_TO_NAMES;

struct ItemClientFields {
  enum type {
    CLIENT_BEGIN = 0,
    BIND_TYPE = 0,
    STACK_COUNT = 1,
    CLIENT_END = 2
  };
};

extern const std::map<int, const char*> _ItemClientFields_VALUES_TO_NAMES;

struct ItemServerFields {
  enum type {
    SERVER_BEGIN = 0,
    SERVER_END = 1
  };
};

extern const std::map<int, const char*> _ItemServerFields_VALUES_TO_NAMES;

struct BindRequireType {
  enum type {
    NOT_BIND = 0,
    BIND = 1,
    BOTH = 2
  };
};

extern const std::map<int, const char*> _BindRequireType_VALUES_TO_NAMES;

struct ItemUseRoleStatus {
  enum type {
    LIVE = 0,
    DIED = 1,
    ALL = 2
  };
};

extern const std::map<int, const char*> _ItemUseRoleStatus_VALUES_TO_NAMES;


class ItemClientField {
 public:

  static const char* ascii_fingerprint; // = "46A703A33337BED2F62F386FC66B2A5F";
  static const uint8_t binary_fingerprint[16]; // = {0x46,0xA7,0x03,0xA3,0x33,0x37,0xBE,0xD2,0xF6,0x2F,0x38,0x6F,0xC6,0x6B,0x2A,0x5F};

  ItemClientField() : field_((ItemClientFields::type)0), value_(0) {
  }

  virtual ~ItemClientField() throw() {}

  ItemClientFields::type field_;
  int32_t value_;

  void __set_field_(const ItemClientFields::type val) {
    field_ = val;
  }

  void __set_value_(const int32_t val) {
    value_ = val;
  }

  bool operator == (const ItemClientField & rhs) const
  {
    if (!(field_ == rhs.field_))
      return false;
    if (!(value_ == rhs.value_))
      return false;
    return true;
  }
  bool operator != (const ItemClientField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemClientField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ItemClientField &a, ItemClientField &b);


class ItemServerField {
 public:

  static const char* ascii_fingerprint; // = "46A703A33337BED2F62F386FC66B2A5F";
  static const uint8_t binary_fingerprint[16]; // = {0x46,0xA7,0x03,0xA3,0x33,0x37,0xBE,0xD2,0xF6,0x2F,0x38,0x6F,0xC6,0x6B,0x2A,0x5F};

  ItemServerField() : field_((ItemServerFields::type)0), value_(0) {
  }

  virtual ~ItemServerField() throw() {}

  ItemServerFields::type field_;
  int32_t value_;

  void __set_field_(const ItemServerFields::type val) {
    field_ = val;
  }

  void __set_value_(const int32_t val) {
    value_ = val;
  }

  bool operator == (const ItemServerField & rhs) const
  {
    if (!(field_ == rhs.field_))
      return false;
    if (!(value_ == rhs.value_))
      return false;
    return true;
  }
  bool operator != (const ItemServerField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemServerField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ItemServerField &a, ItemServerField &b);


class AddItemFields {
 public:

  static const char* ascii_fingerprint; // = "03F2C7B3E06E58B9DDF92A0DE228138B";
  static const uint8_t binary_fingerprint[16]; // = {0x03,0xF2,0xC7,0xB3,0xE0,0x6E,0x58,0xB9,0xDD,0xF9,0x2A,0x0D,0xE2,0x28,0x13,0x8B};

  AddItemFields() : item_template_(0), number_(0), bind_(0), intensify_level_(0) {
  }

  virtual ~AddItemFields() throw() {}

  int32_t item_template_;
  int32_t number_;
  bool bind_;
  int32_t intensify_level_;

  void __set_item_template_(const int32_t val) {
    item_template_ = val;
  }

  void __set_number_(const int32_t val) {
    number_ = val;
  }

  void __set_bind_(const bool val) {
    bind_ = val;
  }

  void __set_intensify_level_(const int32_t val) {
    intensify_level_ = val;
  }

  bool operator == (const AddItemFields & rhs) const
  {
    if (!(item_template_ == rhs.item_template_))
      return false;
    if (!(number_ == rhs.number_))
      return false;
    if (!(bind_ == rhs.bind_))
      return false;
    if (!(intensify_level_ == rhs.intensify_level_))
      return false;
    return true;
  }
  bool operator != (const AddItemFields &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddItemFields & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AddItemFields &a, AddItemFields &b);

typedef struct _ItemFields__isset {
  _ItemFields__isset() : equipment_client_fields_(false), first_equip_time_(false) {}
  bool equipment_client_fields_;
  bool first_equip_time_;
} _ItemFields__isset;

class ItemFields {
 public:

  static const char* ascii_fingerprint; // = "87C12C4601E4F64A4BB77527DB5F4F55";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xC1,0x2C,0x46,0x01,0xE4,0xF6,0x4A,0x4B,0xB7,0x75,0x27,0xDB,0x5F,0x4F,0x55};

  ItemFields() : id_(), template_id_(0), type_((ItemType::type)0), location_(0), first_equip_time_() {
  }

  virtual ~ItemFields() throw() {}

  std::string id_;
  int32_t template_id_;
  ItemType::type type_;
  int16_t location_;
  std::vector<int32_t>  item_client_fields_;
  std::vector<int32_t>  equipment_client_fields_;
  std::string first_equip_time_;

  _ItemFields__isset __isset;

  void __set_id_(const std::string& val) {
    id_ = val;
  }

  void __set_template_id_(const int32_t val) {
    template_id_ = val;
  }

  void __set_type_(const ItemType::type val) {
    type_ = val;
  }

  void __set_location_(const int16_t val) {
    location_ = val;
  }

  void __set_item_client_fields_(const std::vector<int32_t> & val) {
    item_client_fields_ = val;
  }

  void __set_equipment_client_fields_(const std::vector<int32_t> & val) {
    equipment_client_fields_ = val;
    __isset.equipment_client_fields_ = true;
  }

  void __set_first_equip_time_(const std::string& val) {
    first_equip_time_ = val;
    __isset.first_equip_time_ = true;
  }

  bool operator == (const ItemFields & rhs) const
  {
    if (!(id_ == rhs.id_))
      return false;
    if (!(template_id_ == rhs.template_id_))
      return false;
    if (!(type_ == rhs.type_))
      return false;
    if (!(location_ == rhs.location_))
      return false;
    if (!(item_client_fields_ == rhs.item_client_fields_))
      return false;
    if (__isset.equipment_client_fields_ != rhs.__isset.equipment_client_fields_)
      return false;
    else if (__isset.equipment_client_fields_ && !(equipment_client_fields_ == rhs.equipment_client_fields_))
      return false;
    if (__isset.first_equip_time_ != rhs.__isset.first_equip_time_)
      return false;
    else if (__isset.first_equip_time_ && !(first_equip_time_ == rhs.first_equip_time_))
      return false;
    return true;
  }
  bool operator != (const ItemFields &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemFields & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ItemFields &a, ItemFields &b);

} // namespace

#endif
